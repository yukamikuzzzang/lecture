코딩은 속도에 따라 연봉의 차이가 난다.
UI든 Front이든 App이든..
보통은 웹프로그래밍 쪽으로 많이 간다.
_단가라는 것이 거의 정해져 있는 (경기에 따라)
_단가가 높은 쪽이 서버 쪽. <업무 로직을 구현하기 때문에>

똑같은 프로그램을 만드는 데 연봉이 높은 부분? UI 부분(국비)
원리나 그런거 몰라도 할 수 있는 과정들.
초반엔 비슷하나 나중에 편차가 벌어지기 시작.
속도의 문제.

20years ago.
App UI Programmer: 화면 틀만 만드는 친구.
Myfirewall_연봉이 1억이었다고.. : 만드는데 1주일(보통은 1달)

MDI
sts
다른 이름으로 저장 창
과 같은 친구

PyQt 파이썬으로 UI창을 만드는 것.
이렇게 해보자. 저렇게 해보자..
선택의 폭이 넓어지기 때문에

*내가 가는 분야. 
툴과 환경이 결정이 되는데
외워야할 수 있을 정도로 할 수 있도록 해야한다.

레퍼런스만을 보며 따라치기에는 속도가 상당히 느려진다.
네트워크 프로그래밍..> 이쪽 부분만을 주구장창한다.

코어 개발자는 자기 분야가 있기 마련.
ex) 동영상 플레이어.
아프리카tv 개발자가 동영상 플레이어를 만듦.
영상..> 파일이 압축되어 있음. + 네트워크로 전송해서 보여줘야 함.
최대한 압축해서 보내고, 최대한 풀어서 보여주고

영상 압축기술. <코덱:압축기술 = 기술의 집약체>
여러타입의 영상을 화면에 보여줄 수 있어야함.
다양한 코덱을 다 지원하기 때문에. 
알집도 다 공개된 기술. PKG 공개되어있던 기술.

지금은
- 속도의 문제
누구나 개발 가능하다.
그러나 속도가 중요하다.

***
그 사람들은 이미 이런 것들을 숙지하고 이행하고 있다는 것.
함수명이 그렇게 나온다 하더라도 기본로직 같은 것들은 알고 있어야한다.
***

이 친구가 뭐하는 함수고 어떻게 사용하는 친구인지 알 필요가 있다.

#코드리뷰 p.41

stdin > 키보드
stdout > 콘솔 모니터

표준 입력_0, 출력_1, 오류_2
#include <winsock2.h>

WSADATA: 구조체
WSAStartup
윈도우에서 소켓을 쓰려면 특별한 친구가 필요하다.
소켓: 오래된 프로그램 기법.

socket 표준 네트워크 프로그램 방식.
*윈도우즈는 나중에 개발된 것 : 특허 침해..!
내부로직은 전통적인 방식을 따르지 않았을 수도 있다. (우리는 알 필요 없지만)

MAKEWORD(2,2) : 버전 2.2

소켓 객체를 만들기전 WSAStartup을 만들고 간다고 생각하자.
socket
내 프로그램이 그 IP를 선점하기 위해서.
IP --socket-- (OS)네트워크 관리자 --socket-- IP

통제를 위해 OS에게 요구하는 방식으로 진행.
C로 구현하는 것들. 코어 개발자나 통신회사들을 제외하면.. 코딩을 거의하지 않을 꺼임.

이걸 배우는 이유.
통신 프로그램에 대한 기본목적을 알기 위함. 
(장애나 문제가 생김. 네트워크를 이해를 못하면.. 원인을 알지 못해 / 그저 코더일 뿐)
(파라미터를 넘기고 받는 것을 정함.)
(한 명이 프론트, 백엔드 다 개발하는 것은 아님.)
(서버 개발자들. 자부심이 높음.)

SSL 끄고 whileshark로 네트워크 패킷을 잡아서 규약대로 들어오는지를 확인.
네트워크 확인하는 사람은 더욱 주의해야함.
TCP 헤더에 옵션:에 따라 내용이 달라질 수 있음.
load balancing (10만, 100만, ....)
최종적으로 개발자가 다 원인을 밝혀주어야함.

방화벽:IDS, ... etc
얘네들이 찾아가는 방식이 있음. blocking, redialing..
패킷을 받을 때에 반응이 다름.
<그저 내 입장에선 똑같이 안되는 것일 뿐이지만 그것을 알려줄 수 있어야하는 것.>

네트워크 소켓(메커니즘)을 알아야 트러블 슈팅을 하여 단가를 올릴 수 있다.
메모리
프로세스 당 가상메모리를 4g 정도 쓸 수 있다고.

메모리 영역 = 
커널 OS가 사용하는 부분 [절대주소]
+ 사용자 메모리


https : 암호통신을 한다는 것.
코드에다가 SSL 라이브러리를 붙여야
Socket Provider에서 암호화를 한다.
응용프로그램에서 암호화를 하는 것이 아니라..

어플리케이션에 기생하기엔 쉽지 않기 때문에
hServSock: hANDLE + ServSock

MFC, 후킹, 디버거 등등을 알아야 '이해'할 수 있겠지만..
처음에 개발자가 되면 장애처리에 어려움을 겪음.

'본인'은 자기 잘못이 없다고 함.
일정이 늘어지고.. (혼자 해결해야지..)
팀장은 코드를 잘 모르는 상황이기에
팀장 입장에선 얘 잘못하네.. 하며 판단할 수 있다.


WSAStartup을 먼저 만들어주고 시작한다는 부분은 확실히 알아두자.
socket(PF_INET, SOCK_STREAM, 0)

socket()함수에 필요한 세가지의 파라미터.
socket(int domain, int type, int protocol)
(윈도우즈에서 리턴되는 값은 handle)
(리눅스에선 소켓 디스크립터:sd)

domain: 어떤 영역에서 통신할 것인가?
p.51
PF_INET		ipv4
PF_INET6		ipv6

type: SOCK_STREAM(TCP), SOCK_DGRAM(UDP), SOCK_RAW(사용자 정의): TCP와 동급의 프로토콜을 만들 수 있음.
TCP: 서로간의 연결을 확인함.
UDP: 확인절차 없이 보내기만 함.

protocol:
어떤 프로토콜의 값을 결정하는 것.
------------------------------------------------------

&wsaData매개변수 필요.

서버 역할을 할 포트나 어떤 랜카드에서의 접속을 허용할 것인지를
socket provider에게 알려줘야함.
(내가 이 포트 쓰겠다. 라고 커널에게 알려주는 것.)
: bind

~.sin_family = AF_INET :ipv4
servAddr.sin_addr.s_addr=htonl(INADDR+ANY) : 어떤 IP든 OK
~.sin_port = ~ :포트 번호
SOCKADDR* &servAddr
서버의 여러 랜카드가 존재하기 때문에..

거절 당할까봐 이에 대한 준비수단을 마련해둠.

p.72 바이트 오더
byte order
- big endian   01 03   03 01(16진수)	0x0103 0x0301  (16bit) => 0x01030301 (32bit, 32진수)
- little endian  03 01   01 03(16진수)  0x0103 0x0301  (16bit) => 0x03010103

데이터를 저장하거나 쓸 때 사용하는 방식.
윈도우즈: little endian 
Apple: big endian

비트 단위로 보내는 것이기에..
위는 큰거부터
작은 거는 작은거부터 보낸다.

그래서 이걸 정했다.
네트워크에선 Big Endian 방식으로 통일했다.
이걸 일일이 기억하기는 힘들기에

htonl
Host TO Network Long(4바이트) : 호스트 저장방식을 네트워크 저장방식으로 바꿈.
Host TO Network Short(2바이트)

bind...>
내 주소를 서버로 할당받겠다.

listen...>
기다리겠다.

listen(int sockfd, int backlog)
갑작스럽게 들어온 친구들을 대기시켜줘야..
허용범위를 정하는 것.

이를 넘어서면 오류를 보여줌.

accept 허용여부를 결정
send

closesocket 이후
WSACleanup()

크게 규격을 잡고
세부사항을 채워넣는 연습을 하자.

*클라이언트
서버는 대기.
클라이언트는 할당을 받을 필요가 없음. (bind가 필요없다.)

recv가 있다는 점..

connect할 때는 서버주소와 port를 집어넣어야
기본코드 = WSAstartup bind listen accept send

*주의할 점
정적 라이브러리 -lwsock
동적 라이브러리
인클루드파일 디렉터리 지정.