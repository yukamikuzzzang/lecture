버블정렬
선택정렬
삽입정렬
쉘정렬
힙정렬

정렬문제의 하한
기수정렬
...

#내부 정렬 vs 외부 정렬
기준?
주기억장치(Main Memory)의 공간보다 작다
주기억장치의 공간보다 크다
:삽입, 선택, 삽입, 쉘..

작으면 내부 정렬 >Main memory
크면 외부 정렬    >외부 파일
:다방향, 다단계,...

#시간복잡도에 따른 처리속도
https://en.wikipedia.org/wiki/Sorting_algorithm <표>

선택 정렬	<대체로 느린편>
버블 정렬
삽입 정렬
쉘 정렬	<대체로 빠른편>

#버블정렬 Bubble Sort
이웃하는 숫자를 비교
오름차순, 내림차순

32 24

A = 32
B = 24

tmp = A
A = B
B = tmp

if 문으로 두 값을 비교해서
숫자가 크고 작다.
이러한 과정을 통해 정렬하는 방법이 버블정렬
작은 값이 올라가는 느낌이 버블 같아서 버블 정렬

패스단위로 이루어지는 버블 정렬
n개의 원소가 있다면 <적어도> **(n-1)**번의 패스가 수행.

**
BubbleSort
입력: 크기가 n개인 배열
출력: 정렬된 배열

for pass = 1 to n-1
    for i = 1 to n-pass
       if(A[i-1]>A[i])
         A[i-1] <>A[i]
return A

pass = 1이면 (n-1)번 비교
pass = 2이면 (n-2)번 비교
...
pass=n-1이면 1번 비교

총 비교횟수 > n(n-1)/2
시간복잡도? O(n^2)

HEMS 문제들
버블정렬이 수행되는 과정을 보이라
선택정렬이 수행되는 과정을 보이라
삽입정렬이 수행되는 과정을 보이라
...

선택정렬
시간복잡도가 버블정렬과 같음.
항상 일정한 시간복잡도(자료 순서와 관계없이)

삽입정렬
배열을 정렬된 부분/ 그렇지 않은 부분으로 나눔
정렬 안된 부분의 가장 왼쪽 원소를 정렬된 부분의 적절한 위치에 삽입

FOR문을 돌릴때 감소됨.

정렬 안된 부분의 숫자 하나가
정렬된 부분의 삽입.
정렬된 부분의 원소 수가 1개 늘어남.
그렇지 않은 부분은 1개가 줄어듬.
그렇게 모든 알고리즘이 정렬

각각의 정렬방법을 제대로 기억하기.
쉘 정렬에 경우 구간을 두어서 
구간에서 떨어진 숫자들끼리 비교된 것을 정렬을 다시 하고
tmp에 저장된 내용을 계획된 위치에다가 계속 for문이 다 넣은 다음에 
gap 값을 줄여주고..

