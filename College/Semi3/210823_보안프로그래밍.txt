20210823:보안프로그래밍(1)
#책이 꼭 필요한 과목

단방향함수 
해당 암호의 역함수가 존재하지 않는다는 의미(해시함수가 이에 해당)
(19~20xx초에 주로 개발)

SSL/TLS
(SSL = TLS 거의 같은 의미)

Mosaic:HTML만 보여주던 친구
Netscape:95년도 즈음, 컨셉:플러그인
처음 만들어진 것들에 기능을 확장하는 것

Secure Sockets Layere를 최초로 가지고 들어온 친구
SSL1 > SSL2.0부터 상업적으로 사용
SSL3.0부터 업그레이드 부여 > TLS=Transport Layer Security: 공식 프로토콜로 규정

양단 간에 신뢰성 있는 정보공유가 가능
신뢰성 있는 정보를 공유하는 절차를 보여줌.

브라우저를 뜯어본다면 나오는 내용들.
<>

암호화, 보안유지에 있어서 필수라는 점. (좋아요)
그러나 실제로는 그렇지 않다.

https://
요즘엔 거의 다 붙어있는 https://
http 7계층 프로토콜에서 SSL/TLS와 같은 방식을 사용

그러나 암호화하게 되는 경우 속도가 줄어듬.
https://에는 서버 인증서가 필요.

권위 있는 누군가가 얘는 문제 없다고 선언해주어야함.
1. 오버하는 것?
2. 돈이 들어가는 것

암호화가 반드시 필요한 정보는 무엇이 있을까?
1. 컨텐츠가 복호화되는 정보인가? 그러면 안되는 건가?
[해시계열 함수 / 블록 함수]
[작은 거, 복호화x/ 큰 거, 복호화o]
ex) 주민번호를 암호화, 식별번호는 누군가가 알 수 있어야 함. 복호화가 되어야하는 친구.
ex) 비밀번호, 복호화가 되는 경우 위험. 나만 알아도 됨.

2. 그 암호화의 강도를 따져야 함.
그 강도를 자의적으로 결정할 수 없음.
보안강도에 대해 권고해줌.

10년 정도 지나게 되면 권고 정도가 바뀌게 됨.
2^128 정도는 견딜 수 있는 것들이 적당.
<>

#해쉬함수
임의길이의 정보를 입력 > 해쉬함수 > [고정길이]의 암호문(해쉬값)
암호문 > 해쉬함수 -X> 원본의 내용

HAS-160		
SHA-1		
SHA-224		
SHA-256		
SHA-384		
SHA-512		


80비트의 보안강도 ... 2^80의 연산을 해야 알고리즘의 취약성을 알 수 있을 정도.
2013년까지 112비트이상의 보안강도를 가질 것을 권고

SHA-224~
-256
-384
-512
!권고!


#블록암호 알고리즘
암호화, 복호화할 때 키 값이 같음. <비밀키>

SEED(1990) 	HIGHT 	ARIA 		AES(2000)	TDEA
128		128	128/192/256	128/192/256	112/68
				
abc.zip SHA-256
악의적으로 파일 내용을 위변조하더라도 해시값을 대조하게 되면 속일 수 없음.

14:10
(2)
웹서버들이 https 프로토콜을 사용하기 위해선..
SSL/TLS 통신암호 개념

User ..> https://
인증기관(CA) ..> SSL 인증서 발급


윈도우 서버엔 CA가 들어가 있음.
https://가 가능하게 됨.

다른 OS에서도 인증서를 발급하게끔 한다면 인증서발급이 가능.
다만.. 문제가 있다?
신뢰할 수 없는 인증서입니다. 라면서 뜨는 알람.
그래서 돈을 주는 쪽이 편안..

인증서발급기관에서 절차 진행.
SSL 프로토콜 상에서 단계가 필요.

앞으로 프로토콜을 설계해서 만들 일은 없을 듯..? Network Lab에서 주로 만드는 프로토콜 설계.
컨셉을 안다면 굳이 속까지 알지 않아도 괜춘.

************<시험에 나옴>
<> 처음에 접근할 때에 신뢰성 있는 대상에게 접근해야함.
   적법한 대상을 찾아야한다.

<> 내용이 탈취되더라도 그 내용을 알 수 없어야 한다.
   서로 쓰는 암호가 같아야한다.
   양단 간 쓸 알고리즘과 키 값을 알 수 있어야 한다.

<> 어떤 수순을 밟아야 위와 같은 과정을 거쳐 내용을 주고받을 수 있음.

사용자, SSL/TLS서버
1> 사용자가 서버에 접속/ 나 너랑 암호화 통신하고 싶어, 너도 할래?

<1 OK, 양단 간 암호 및 해쉬 알고리즘 테스트
[Handshaking Protocol]

(웹브라우저 버전이 낮다면 사용하는 알고리즘의 개수가 많지 않음)
(키의 크기도 다름)

알고리즘 결정 후
2> 클라이언트가 키를 만들어 보냄. 이때 반드시 그 키를 웹서버 인증
암호화 서버에 공개키를 보내면 <서버가> 비밀키로 키 값을 풀어냄.
클라이언트가 만든 키를 안전하게 보낼 수 있도록 함.

/서버 네트워크 상에 무작위로 존재하는 공개키/
[SSL/TLS 프로토콜을 바탕으로 '사용자'가 브라우저에서 서버의 공개키를 가지고 키를 만듬.
서버는 '사용자'가 만든 키를 받아서 비밀키로 암호화를 해제]


<2 공개키로 서버 키 정보를 획득, 공개키로 보냄
사용자는 비밀키로 이를 복호화 후 정보 획득.


*웹서버 인증을 받으면 공개키와 비밀키를 받음.
공개키: 공개되어 있음[이 세상 누구도 A사이트를 접근할 수 있음을 의미]
비밀키: 나만 가지고 있음

공개키로 암호화하면 비밀키로 풀림.
비밀키로 암호화하면 공개키로 풀림.

비밀키는 사이트가 가지고 있음.
공개키 자체는 아무 의미가 없음.

[자체적으로 만든 인증서의 경우 신뢰성있는 인증서로서 역할하지 못함.]

...>이후 암호화 데이터를 주고 받을 수 있음.
프로토콜 spec을 살펴보면 이에 대한 정보들이 다 나와있음.
하지만.. 그 정도까지 알 필욘 없다.

***SALT의 컨셉을 잘 익혀두자.
#SALT
단순해시 값이 아닌 SALT
해시 알고리즘은 이미 다 오픈되어있음. 의미가 없음.

패스워드를 잘 만드는 것은 유저의 책임.
회사로서의 책임?

비밀번호 + SALT > [해시 알고리즘] > 해시함수
순수한 비밀번호를 알기 어려워짐.
(앞,뒤 사이에 가능..)

SALT가 어떻게 붙는지 알게되는 순간, 큰일날 수 있음.
SALT를 유저마다 다르게 할 수 있도록 권고하지만 쉽지 않음.

해시에 해시에 해시를 적용할 수도 있음.
결과를 통해 역추적하는 경우는 거의 없음.
인구통계학적인 정보를 통해 유추하는 경우가 많음.

암호화를 대하는 컨셉..!


실무적으로 사용할 때엔 어떻게 적용하는지에 대한 내용들..<은 스킵>

31p
암호키를 생성하고 보관하는 내용.

(3)
35p
4. 암호기술 구현방법
SHA-256 개인정보 DB 암호화
SEED를 이용한 개인정보 DB 암호화

1 ASP: 책도 안나온다고 함..
2 JSP: 있는 소스를 돌려보는 것.

이클립스 Enterprise Version 필요.
웹서버 필요. with Tomcat 9.0(java8과 호환)

SHA-256를 사용해서 얻은 결과
SEED를 사용해서 얻은 결과

자바빈으로 구현한 친구들.
소스를 수정하진 못함.
그저 돌리기만 한다면 예제 웹페이지가 나옴.

<요즘 꺼론 안된다고 하심..>
[다음주에 과제물이 나갈껀데.. 그게 이거임]
[이 환경을 구축해서 돌려서 화면 캡쳐해서 돌리면 됨.]
[실제로 써서 돌아가는 모습을 최소 2컷으로 해서 올리는 방식]

[jsp. jdk1.8꺼 써야함.]
https://www.eclipse.org/downloads/packages/release/2020-03/r
이클립스 2020-03버전 다운로드
(6월버전까지는 괜춘한데 혹시 모르니)

EE버전 다운로드 받으셔요.
제공하는 버전을 그저 붙여서 돌리는 느낌.

원교수님께 말씀드려서 바로 이어서 할 수 있도록 하려고 함..?