오늘은 진도를 좀 나가고
다음주엔 시험과 관련한 이야기들을 할 예정.

<1>
버블 정렬, 선택 정렬, 삽입 정렬, 쉘 정렬, 기수 정렬. 퀵 정렬

퀵 정렬: 피벗을 기준으로 나누어 진행.
비교해가며 합쳐가는..

퀵: 문제를 2개로 분할, 부분 문제의 크기를 일정하지 않은 크기로 감소하는 알고리즘
이진탐색: 상위에 있는 부모에 대해 조건에 맞게 알고리즘을 짜는 것.

1. 퀵 정렬
2. 선택 문제 알고리즘
	문제를 분할하여 특정 위치에 있는 것들을 찾아줌.
	삽입 정렬, 피보나치 수의 계산 등등..

피봇을 잡는 것, 보내는 방법들에 따라서 처리속도가 달라짐.

QuickSort(A, left, right)

A: list
분할을 지속하다보면 left == right인 시점이 옴.
1. 피봇을 A[left]~A[right]에서 선택

[        P       ]
[   P   ][   P   ]
...

피벗을 0번 자리로 이동시킨 후
값을 비교해나감.

Low(왼)방향 쪽에 있는 값 중 피벗보다 큰 값
High(오)방향 쪽에 있는 값 중 피벗보다 작은 값을 골라
이 두 값을 바꾸어나간다.

<2~3>
지난 시간에 했던 방법
리스트의 중간값을 찾아서 피봇으로 취급하고 이행.
	- 랜덤하게 선정하는 방법
	- 3 숫자의 중앙값을 선정하는 방법
pivot = A[left]
피벗을 어떻게 선정하느냐에 따라 프로그램의 효율성을 추릴 수 있음.

선택 문제 알고리즘
선택 문제? 
n개의 숫자들 중 k 번째 작은 숫자를 찾는 문제
	(1) 이미 정렬이 되어 있다면 분명 더 빨리 찾을 수 있음.
	(2) 정렬을 하지 않는다면 피봇 값을 부여하여 양쪽을 나눠가며 찾아감.

-단순한 알고리즘
최소 숫자를 k번 찾는다.
<이진탐색 / 선택문제>

Selection(A, left, right, k) 'k!'
피봇을 A[left]의 자리로 바꿈
피봇과 배열에 들어있는 요소를 비교
피봇보다 작은 숫자는 왼쪽에 큰 숫자는 오른쪽으로 보내어 파티션

S = (p-1) - left + 1 #S: small group
if(K<=S) Selection(A, left, p-1, k)

[다음주 예고]
/*최소 신장 트리, 최단 경로 찾기, 부분 배낭 문제
집합 커버 문제, 작업 스케줄링, 허프만 압축*/

동전 알고리즘? : 그리디 알고리즘
동전 거스름돈 문제 해결의 가장 간단하고 효율적인 방법

거스름돈 단위:100 500 1000 5000 10000
금액을 받고...

while(x>=10000):
change= change-500,n500++
....


