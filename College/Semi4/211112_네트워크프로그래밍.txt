스레드가 파일입출력을 담당하게 되는 경우
메인이 끝나버리면 파일입출력이 사라지는 현상 발생.

그래서 스레드가 끝나기 전까지 기다리는 함수가 있음.
WaitForSingleObject //객체가 하나일 때
object ... > thread 객체에 대한 HANDLE 값으로 대기.

while(1) { }
무한대기 발생 시 먹통이 되는 경우 발생.

대비책:
int endgame = FALSE // 전역변수 생성
endgame = TRUE

while(!endgame) { }
실제 솔루션에서도 사용한다고.

종료할 때 while문을 빠져나가는 데 필요한 시간이 있으므로
waitforsingleobject를 사용.

최소 51개
NUM_THREAD 개수만큼의 스레드 + 메인 스레드

스레드를 프로세스에 붙여서 실행시킬 수 있다는 점.
짝수면 -1  Des
홀수면 +1 Inc

CPU의 스케줄링 + OS + 커널..
실행하는 속도가 달라지는 점..
number의 결과값이 계속해서 바뀔 수 밖에 없다.

WaitForObject하는 데 왜 num값이 매번 달라질까?


메모리에서 값을 가져와 num에 넣음(fetch)

CPU로 가져와 : num + 1

또 다른 친구가 (fetch)

25개의 친구들이 중구난방으로 fetch가 일어남.
fetch한 값은 0 -> num
이 값을 동시에 메모리에 넣는다면 num이 1이 됨.

한 두 개에서 이러한 불상사가 일어날 수 있음.

****
동시에 read를 하는 것은 상관없으나..
동시에 write하는 경우가 생길 때엔
다른 스레드가 접근할 수 없도록 해야함.
****

p.448

critical_section		임계영역
mutexcultual Exclusion	상호배타 / 뮤텍스 ***
semaphore		세마포어
(Windows)even기반 동기화

(본인은) 뮤텍스를 많이 썼음.
다른 언어에도 존재하는 영역.
특히 멀티플렉스 언어에서 필요.

스레드(지역변수)일 경우
스택에 쌓는데 운영체제별로 순서가 다르다.
SyncMutex.cpp를 보면
이에 대한 순서를 알려줘야한다.

윈도우즈는 이러한 순서를 안따른다..

IT 쪽에서는 경쟁과 독점..
1위, 2위 업체를 제외하면 난리남.

0과 1

0쪽으로 간 업체, 1쪽으로 간 업체
특허로 고통받기에..
후발주자가 힘든 IT계

SyntaxMutex.cpp
Thread 관리
OS에 있음.

Mem
사용자
커널

Mutex를 소유하면 실행하고
그렇지 못하면 대기해야함.

소유하는 순간 다른 친구가 접근하지 못함.
뮤텍스 handle 값을 리턴 받기에 커널메모리에 있음.

Mutex는 handle 값이기에 전역변수로 지정.

WaitForSingleObject(hMutex, ~)
//뮤텍스를 소지하고 있는 자가 없다면 넘어감
//그렇지 않다면 그때까지 기다림
//커널에 있는 뮤텍스

ReleaseMutex() 
//뮤텍스 소유권을 놓음

하나의 스레드가 작동하는 동안
나머지 49개의 스레드는 대기해야함.
WaitForSingleObject

for문이 5천만번이나 도는 프로그램은
별로 좋지 않은 프로그램.

5천만번이나 돌때까지 기다리는 것은 별로 좋지 않음.
파일 입출력은 메모리 안에서 동작하는 것보다 더 오래걸림.
파일 입출력을 진행할 때에 CPU를 진행시킨다면?

안에서 루프도는 것 자체는 큰 문제
락을 거는 시간 자체가 줄어들면 프로그램이 동시에
시작되는 것 같은 느낌.

+람다

주요함수부분을 주석으로 남김.
실행프로그램(exe)로 2명 이상 참여하는 채팅 화면 캡쳐 이미지 호출

1. 함수들에 대한 설명 코멘트가 포함된 소스코드
2. 클라이언트/ 서버 실행 프로그램
3. 채팅 화면 캡쳐 이미지

Winsock DLL 초기화 함수로 버전 2.2와 호환되도록 한다.

~함수로 ~을 한다.
코멘트를 처리해서 포함시키도록 하자.
취업한 사람들도 포함...

event?

윈도우가 있는 경우에 해당.
브라우저?도 윈도우?

창 자체가 윈도우
LeftMouseClick
RightMouseClick

윈도우에선 메세지 큐 방식.
마우스를 클릭할 시에 시그널이 발생한다고 함.
시그널:전기신호(물리)
클릭(논리)

이벤트 보단 메세지라는 걸 많이 쓴다고 함.
메커니즘.

클릭메세지가 큐(전역 [메시지] 큐)에 쌓임.
전역: 윈도우 시스템 전체를 일컬음.

어떤 한정된 프로세스가 아님.
윈도우즈가 하나 생성이 되면
하나의 exe 안에 다양한 프로그램이 있음.


메인 윈도우에도 똑같이 메시지 큐가 존재.
시스템은 현재 누구한테나 메시지를 주어야함.
큐에 있다가 메시지가 들어오면 이걸...
현재 활성화(active)된 윈도우에게 준다.

<코딩 하지 않아도 들어가있는 메시지 큐>

메모장 활성화시..


활성화된 메인 > 서브
서브 윈도우 중 활성화된 친구...

메시지 큐를 감시하는 친구가 꼭 필요함.
코드가 정형화되어 있기 마련.

데스크탑은 시스템이 관제
메인 윈도우는 해당 시스템이 관제

OnClickEventListener
<<와 같은 함수를 정의해놓으면 감시 관제

이벤트로 받고
이벤트 큐에서 ... 활성화된 윈도우로 보내줌.
메시지 큐 방식.

메시지 큐를 쌓고
메인 윈도우 보내고
활성화된 서브 윈도우(child)에 보내고

기본 함수
OnClick()

객체함수에선
클릭과 관련된 클래스를 상속받아서 구현

Mark커널에서 배껴가지고 만든 친구라고..
or Mac

메세지 큐 방식을 알고 있어야..
윈도우 프로그래밍을 할 때는 항상들어가는 개념이라고 함.