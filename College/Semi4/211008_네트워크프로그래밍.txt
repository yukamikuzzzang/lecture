UDP 세션 연결을 할 필요가 없다.

TCP  A---B connection
A~B3까지 연결하고 싶다면 소켓이 3개 필요

UDP A B,B2,B3..
같은 상황에서 소켓 1개 필요

Windows OS
SOCKET 관리자(네트워크 관리자)
메모리를 차지
여러개의 socket을 관리
           동기화 메커니즘 필요

Thread P/G(Program)

CPU (1)
OS cunnel 메모리 > 모든 프로세스가 공유하는 메모리
사용자 프로세스가 건드리지 못하는 커널 영역
윗 부분의 존재하는 사용자 영역

소켓 관련된 객체들을 만들어놔야..
메모리 할당한다. like C

커널 영역에선 같은 메모리를 공유하기에 서로 충돌하면 안됨.
커널 영역에서 실행하는 데에 스케줄링이 필요.

커널이 처리해야하는 양이 더 많아짐.
높은 신뢰도 + 높은 복잡성

CPU 관리가 필요하고 자원관리 등등 고려해야할 것들이 많음.
UDP로 하면 이런 것들을 관리하는 것이 덜함. <UDP:스트리밍 etc>

보통 보안 프로그래밍에선 잘 안씀.
게임, 스트리밍 등에서 많이 사용.

서버: socket() bind() recvfrom() closesocket()<커널에 할당된 걸 지움> [listen() accept() X, 3-hand-shaking] 
클라이언트: socket() sendto() recvfrom() closesocket()

msdn socket 윈도우 소켓프로그래밍.

SOCKET WSAAPI
.lib 정적 로딩
.dll 동적 로딩

정적로딩: import 해온 함수를 그대로 사용
실제코드는 동적모듈(.dll)에 다 있음

불러오는 조건? 모든 언어가 호출 가능.
1.리턴 값, 2.함수명, 3.매개변수 리스트
C, Java, Python 등 각각의 언어마다 호출하는 방식이 다름.
타입을 못추어주는 것.

(int, int) <특정한 조건에서 안되는 경우가 발생할 수도 있기에...

10.10.0.10

****************************과제, 채팅프로그램
클라이언트는 그대로 둔 상태에서 
서버만 만들면 무관
****************************

2차원 포인터등을 써야해서 좀 어려울 듯.

C언어로 소켓프로그램을 만들꺼면 해야한다..

네트워크 환경에 따라서
제각각의 로컬망을 쓰고 있기 때문에
공인 IP를 가지고 있는 서버와의 통신을 도모해야한다.

UDP로도 가능은 하나..
신뢰성이 떨어지고 해킹 당할 가능성이 높음.
양방향 통신에서는 보안에 취약. (속도는 빠르지만)

그림 상으론 실시간으로 통신하고 있는 듯 보이지만
실제론 그렇지 않음.

Logic
A1(recv 대기)
A1(send)
A2(recv 대기) - 한 번에 하나씩 밖에 처리를 못하기에

UDP로는 간단하지만 탐탁치 못한 부분이 있음.
단일처리 방식으로는 처리하기 어렵다느 결론이 나옴.

그에 대한 해답으로 멀티프로세스
(우리가 만든 것: 한 번에 하나밖에 처리를 못함.)

각각 돌아가는 .exe와 개별적으로 통신
svr.exe --- A >> 실시간!
svr.exe(2) --- B
svr.exe(3) --- C
...

Unix 계열 	/	 windows
멀티프로세스 구현 방법
fork()

프로세스
A>>>> fork() : A'가 생김.
	       코드는 같은 복사본이 생김.
A(int a = 10)

fork(){
	a=30;
}

부모 프로세스는 fork()를 실행하지 않음 	A, a=10
자식 프로세스는 fork() 수행. 			A', a=30

별도의 프로그램 생성
A listen() >>> accept() > fork() >>> listen()
		        복제
		         A'
		         진행...>

서버 프로그램은 리눅스로 된 것들이 많다.
python 등등이 있지만 속도차이가 있음.
속도에 민감한 것들은 C언어로 많이 사용하기에

(1억짜리 서버... 1000명 되도 버벅거리던 시절..)

윈도우즈
thread 개념
모든 프로세스는 thread가 동작한다. ***

유닉스에선 프로세스가 동작한다.
윈도우즈에선 프로세스는 껍데기. 실행되는 친구는 스레드.


exe안에 존재하는 여러개의 스레드
CPU가 스레드에게 명령을 하면 exe에 있는 코드가 동작.
스레드가 일한다.

스레드의 문제점. 메모리를 공유함.
별도의 로컬 변수를 가지고 있음.

전역변수는 exe안에 있는 자원을 씀.
전역변수는 공유하고
로컬변수는 공유하지 않음
스레드 개념? (추상적인 내용)
작업관리자에서 보면 쓰레드가 하나만 동작.
유닉스에선 하나의 exe에선 하나의 exe만 실행.

그래서 윈도우즈는 보안에 취약.
스레드 개념 때문에 문제..

대신 멀티프로세스를 구현하기에는 윈도우즈가 좋음. <효율적>

유닉스에선 fork 되는 exe는 여러개가 올라가야하는 데 비해
윈도우즈는 하나의 exe로도 가능. <쓰레드 별로 수행>

매개변수 지역변수는 쓰레드 별로 가지고 있다.
전역변수는 모든 쓰레드가 공유한다.

IOCP는 해야하지 않을까..?

한 변수가 동시에 접근했을 때 망가지는 것에 대비한 여러 기법들..
웹 서버에서 fork를 잘 씀. (굳이 하진 말고)

오늘까지 한 것?
함수에 많이 익숙해지는 것이 중요.
함수 위주로 준비
다음주 수시 보고..
중간고사를 보면 될 듯?

좀비프로세스에 대한 얘기도 나옴..
exe가 따로 떨어져있으면 둘이 통신할 필요가 있음(fork 등으로 인해)
통신방법: strings, 공유메모리 etc...

PASS

다음주 UDP로 채팅하는 서버프로그램을 만들어볼 예정.
파이썬에선 그저 list로 편안하게 할 수 있겠지만...
배열을 사용할 예정.
중간고사 보고 나서는.. 멀티프로세싱 쪽으로 배워볼 예정.
네트워크 보단 시스템 프로그램에 가까울 듯.

멀티 스레드... 이해하는데 쉽지 않을 수 있음.
동시에 동작시키고, 공통 변수에 접근하는데 읽기/ 쓰기 접근
(서로 쓰려고 달려들면 난리가 난다..)

하드디스크는 특히 쓰고 읽는데 동기화에 신경을 쓰지 않아도 됨.
커널에서 제공.
그러나 통신은 그렇지 않음.

중간고사 범위 echo client 서버.
TCP 환경에서...

UDP?
recvfrom해서 그냥 보냈지만

TCP에서 null이 오면 내보내고...

하지만 UDP에서는 경계가 존재하기 때문에
루프 돌릴 필요없이 내보내면 됨.

(외산 프로그램은 한글처리가 잘 안되어있기에
한글 경로를 쓰지 않는 것이 좋음.)
우리야 한글 환경이야 오류가 안나지만...




