시그널<>
UDP 
서버는 하나 패킷만 받아서 echo.

여러 개의 클라이언트가 접속해도 문제가 없는 형태.
대신 보안에 약하기에 많이 사용하지는 않는다고.
명확하게 누가 접속했는지를 판단하기 좋기에 TCP를 사용.

TCP - 연결지향형
다른 친구가 들어오면 처리하기가 애매함.
여러 클라이언트가 들어올 수 있도록 하는 방법.
'멀티프로세스'
안정화되며 괜찮은 친구 - like apache

프로세스가 여러 개 뜨는 상황.
관리하는 입장에서 어떤 친구가 죽는지 등을 알 필요가 있음.
(연결이 종료되었을 때 처리해야할 필요가 있다.)
with Signal.

단순히 출력만 하도록 함.
원래는 여기서 다양한 처리를 함.

Signal이 발생했을 때 수행하는 함수 등록.
sigchild_handler 호출

sock, bind까진 동일.
signal이 발생하면 SIGCHILD가 발생하도록 해야.
child 프로세스가 종료가 되면...

bind는 동일.
IP 커널을 할당받음.
listen한 뒤. accept가 들어오면 fork를 쓴다.

서버는 항상 대기하고 있다가 다른 프로세스와 소통.

FORK
:프로세스의 코드영역 메모리 영역을 그대로 복제
:변수 값이 동일.

클라이언트에선 서버 소켓을 종료시킴.
close로 종료하면 fork한 child 프로세스가 종료되면
signal이 발생하며 sigchild_handler가 실행.
클라이언트의 DB등과 관련된 것들을 삭제.

bind
accept : 클라이언트가 접속이 있을 때까지 대기하는 것.

socket할 때 signal을 등록. SIGCHILD
child 프로세스가 멈추거나 종료되면 parent 프로세스에게 SIGCHILD를 (OS가) 보내줌.

signal이 들어오면 이 프로세스를 처리해야하는데
accept가 대기하고 있는 상황에서 처리가 가능할까? 답은 X

대기하고 있는 친구를 깨워서 CPU가 일을 하도록 해야함.
sleep(딴 친구가 일하고 있는 상황)하고 있는 친구를 깨워서 수행.

우선순위
시스템 오류 > 시그널 함수 > 다음 우선순위

accpet를 건너 뛰기에...
이에 대한 오류처리가 필요.

오류 값에 EINTR(오류넘버)
errno << 리눅스에 세팅되어 있는 오류에 대한 값.
<접속은 없는데 깨어난 상황 by SIGNAL>
대신 오류에 대한 이유를 숫자로서 세팅한다는 것.

EINTR : 커널에 define문으로 정의

E:error
I:interrupt
시스템 콜 수행 중 인터럽트가 걸려 수행이 중단.
키보드 입력 시그널이 시스템으로 들어감. 시스템 호출.
(키보드에 대한 인터럽트가 들어간 경우 CPU의 작업을 잠시 중지..하는 느낌..!?)

SIG_CHILD가 발생하는 것 또한 인터럽트.
(하고 있는 것을 중단하고 다른 것들을 진행.)
보통은 우리가 처리할 수 없는 경우가 많음. : 무시하자.

11장은 시스템 프로그래밍 부분은 넘어가고
12장을 살펴보자.

p.287
<중간에 시스템 프로그래밍에 대한 얘기가 너무 많아서..>
멀티스레드 etc..

리눅스 개발을 할진 모르겠지만..?!
코딩을 좋아하는 분은 리눅스에서 개발할 일이 많음.
윈도우 환경에서 주로 개발하지만...
리눅스 fork, 윈도우 thread
가장 하기 쉬운 게 windows 기반
고급으로 간다면 inter process call, etc...

기초가 되어있지 않은 상태.

시스템 프로그래밍?
> 고급 프로그래밍
고급 프로그래밍을 요구하는 곳은 따로 있는 편.
프로그램에 관심이 많은 사람들이 주로 한다고...
<관심의 문제?!>

마이크로프로세스?

리눅스와 윈도우즈가 다름.
개념들이 많이 다른 편.
리눅스 시스템 프로그래밍 (커널과 C라이브러리로 돌아가는)

버퍼 입출력
고급 파일 입출력
프로세스 고나리..
프로그램, 프로세스, 스레드 + fork
kill

kill이라는 명령어를 코드를 만드는 것 > 시스템 프로그래밍.
시스템 한테 요청하는 코드 : 시스템 프로그래밍.
프로세스 관리, 스케줄링: 이론으로 배운 것들을 프로그래밍.

리눅스 기반.. Pthread 윈도우즈에선 좀 다름.

파일, 디렉토리: 우리가 생각하는 것 보다 저수준.

read() 
write()
printf()
>사용자가 사용가능한 함수

파일이든 네트워크든 read() <읽기> , write() <쓰기> , printf() <출력>

read() ...> file에 대해 access 가 아님.

사용자 환경
____________

커널 <객체>

read(파일) .....> 커널함수 -read 호출 (+IO 함수 etc) ....> 하드에 접근.
실제 read하는 친구들은 커널에 구현되어 있는 함수들이 있음. OS가 호출하는 방식.

사용자1[프로세스]
write('A.txt') .....> -write() <커널함수>		[1번째]
			같은 커널에서 진행.
사용자2[프로세스]
write('A.txt') .....> -write() <커널함수>		[2번째]

이런 것들을 컨트롤하는 것이 시스템 프로그래밍.
write에 있는 여러 옵션들로 컨트롤.
직접 컨트롤 하지 못하면.. 해킹..
직접 조절해주는 함수가 있다.

Thread 역시 커널과 관련이 있음.

Thread 쓰레드.
자원을 덜 먹음.

process

메모리

<코드>		<---여기서부터 실행
<전역변수>
<지역변수(스택)>
<동적변수(heap)>


fork하면 저 것들을 모두 복사.

스레드

<코드>
<전역변수>	<---같은 전역변수
<지역변수(스택)>
<동적변수(heap)>	<---같은 동적변수를 사용하는 스레드

<지역변수2>	<---지역변수만 복사.

프로세스 중 하나가 해킹 당해도 상관없지만
스레드는 해킹 당하면 저 내용이 모두 드러남.

프로세스는 서로의 변수가 서로의 프로세스에게 영향을 주지 않지만
스레드는 모두에게 영향을 끼침.

스레드가 꼬이지 않도록 하는 것.
스레드 하나가 들어가면 다른 하나는 대기하는 상태로 들어가야함.
코드가 잘못들어가면 무한루프하게 되면서 무한대기 상태가 됨.
너무 오래걸려버리면 타임 아웃시키고 새로운 친구를 받아들이고...

동기화 과정등이 필요.
이러한 것들에 책임을 지는 시스템 프로그래밍.

챕터 19.
스레드: 시스템 프로그래밍 영역.
윈도우즈를 서버로 쓸 때 많이 이용.
메인 스레드
....> child 스레드
....> child 스레드

셋 다 전역변수를 공유한다.

윈도우즈
# ~ <windows.h>
# ~ <process.h>

_beginthreadex(~) : 쓰레드를 만드는함수. fork 같은 것이 아님.

ex(extend, 확장)

스레드마다 실행하는 코드가 다름.

프로세스
______________
전역변수 
스레드1 코드	코드 영역

별도의 공간을 만들고.
스레드 1에서만 돌아가도록 함.

_beginthreadex( .. , ..., ThreadFunc, (void*) &param, 0, &threadID )

ThreadFunc 정의 후 별도의 다른 스레드로 실행할 부분이 밑에 정의되어 있음.

ThreadFunc (void *arg)

&param을 보이드 포인터로 넘겨버림.
보이드 포인터: 어떤 타입이든 다 보이드 포인터로 만들 수 있음.

f(a1, a2, a3, a4, ...)
struct A{
	int a1, a2, a3, .. }
f(A)

threadID 메인에서 관리할 수 있도록 정의

hThread == 0 실행되지 않았다는 뜻.
메인 실행 3초 이후 종료.

내부 함수
cnt값은 param의 값을 받고 5..

	main(	)		ThreadFunction
0초				running thread
1초				running thread
2초				running thread
3초	"end of main"		running thread <출력X>
	<종료>

포크 된것은 별도의 것이라 계속 돌아가는데..
화면에 출력하는 것이 상당히 느리다고 함.
도트 하나당 모두 점을 찍는 일.
CPU에 비해선 확실히 느림.

main과
TF에 대한 것 모두 OS가 결정.

메인 실행이 늦어진다면 TF가 한번 더 찍힐 수 있음.

내부 함수
int i > 지역 변수

main > HANDLE 도 지역변수

ex) int g_checkid = 0

Sleep(2999)
g-checkid = 1  main
g-checkid = 10

1. 전역변수가 공유된다.
2. 스레드는 동시에 각각 실행된다.

누구를 먼저 실행하느냐에 따라 결과값이 달라짐.
