시험범위 6장~10장
6장
함수중복과 스태틱(static)
:같은 이름을 가진 함수가 존재할 수 있다.

함수중복의 성공조건..! 알아두기
(중복된 함수의) 이름 동일
" 매개 변수의 개수/ 타입이 달라야 함.
리턴 타입은 함수중복과 무관

-function overloading
소멸자는 중복이 안됨.
한 클래스 당 하나만 가능

default  매개변수**
매개변수의 값이 넘어가지 않을 경우 기본적으로 받는 값을 의미
void star(int a = 5)

star()  >> default
star(10) >> a=10

**
사용할 때에.. 디폴트 매개 변수는 끝 쪽에 물려 선언(오른쪽부터 채워나가는 느낌.)
인수는 왼쪽부터 들어가기 때문에..
a, b=10, c, d=34 : X
a, b=10, c=20, d=30 : 0

코드가 훨씬 간략해진다.

static VS non-static
공유하는 변수 static
그렇지 않은 모든 것 non-static

static 변수는 초기화를 한 번 해줄 필요가 있음(30p)
(int Person::sharedMoney = 10;)
프로그램 메모리에 미리 올라가 있고 사라짐

***
32p 비교하는 표부분을 잘 살펴보기
Non-static vs static
객체 마다 별도 생성 vs 클래스 당 하나 생성
객체 생명을 같이 함 vs 프로그램과 생명을 같이 함
공유되지 않음 vs 공유됨

**Friend 함수
외부함수
friend라는 키워드로 외부함수를 클래스 내로 가져올 수 있음.
표 부분 유심히 살펴볼 것..!

friend 사용가능 유형?

1. 전역함수
2. 클래스 내부의 특정 함수
3. 클래스 전체의 (모든 멤버) 함수

**연산자 중복
Operator
기본형은 그저 계산하면 문제 없으나
객체형(Class)을 연산해야하는 경우.

class Test{
 int a, int b;
void show();
void operator +(int a);
Test operator + (Test ts);	//연산자 중복
}
int main(){
Test t1(4,5) , tw(3,4,);
Test t=t1+t2;
t1+5;
return 0;
}

객체와 객체간 연산을 할 때 주로 사용
Overloading(재정의)해서 사용

안되는 기호 4개
.	* 	::(범위지정연산자)	?:3형연산자
중복 불가능한 연산자

연산자 함수 구현 방법
1. 클래스의 멤버 함수로 구현
2. 외부 함수로 구현 후 프렌드 함수로 선언

.
*
::
?:
<Overloading 안되는 친구들>18p
코드를 보고 결과를 써라..! 주관식..!!
*************************

기본 클래스?

*********(서술식) - 4점
상속할 때 public private protected 중 하나를 쓸 수 있음..!

public: 기본클래스의 protected , public 멤버 특성을 그대로 계승
private:" 멤버를 private으로 계승
protected:"멤버를 protected, public 멤버를 protected로 계승
스펠링 틀리지 않도록 주의

생성자 + 소멸자
class Base(){
int a;
public:
Base(){cout<<"부모 생성자:"<<endl;}
~Base(){cout<<"부모 소멸자:"<<endl;}
void show(){}
int getA(){}
};

int main(){
 Derived d;
}

************* 요거 문제임. <순서> ㄹㅇ
부모 생성자: //1st
자식 생성자: //2nd
자식 소멸자: //3rd
부모 소멸자: //4th

다중상속
C++ 객체지향이지만 다중상속이 가능한 친구
기본 클래스 멤버에 중복 상속이 가능
comma (,)
하나의 클래스에서 여러군데에 있는 친구들을 상속받아서 쓸 수 있음.
좋긴 한데.. 멤버 (이름)가 같을 경우.. 문제가 된다.

>>가상상속
기본클래스에다가 virtual을 붙여주면
딱 한 번만 상속이 가능하다고..

기본 클래스 멤버는 옺오직 한 번만 생성
가상상속을 통해 다중상속의 모호성을 해결..!

*****
p18
**
오버로딩 vs 동적 바인딩 vs 함수 재정의.. (표) 관계등을 묻는 문제 (7번ppt)
**
순수 가상 함수
class Test{ //추상클래스
virtual void draw() = 0; //순수가상함수
}

추상클래스가 되기 위해 순수가상함수가 1개 이상 있어야함.
또한 이 클래스는 객체를 형성할 수 없음.
** 추상 클래스 만드는 방법..?

10장 템플릿
***주관식에 대한 부분들이 여기서 많이 나온다고 함.

함수중복: 오버로딩!
같은 이름으로 여러개를 만들 수 있으니..
동일한 코드를 중복해서 사용하는 것을 줄이고자. TEMPLTE을 사용..!

템플릿 함수, 템플릿 클래스 etc..

만드는 방법

template <class D>
void myswap(A a)
{

}
//D를 쓰던 T를 쓰던.. 여러 타입이라는 의미로서 T를 쓸 뿐..
Anyway 타입이 하나다 라는 뜻.

template <typename B, typename C>
void myswap(A a,B b)
{

}
template <typename B, typename C, class D>
{

}
이런 느낌으로 함수를 만들거나 클래스 자체를 만들 수도 있음.
template..! >> 클래스/ 함수..

STL; Standard Template Library
<버그 없는 클래스의 집합: 컨테이너 + 반복자 + 알고리즘>
container
리스트, 큐, 스택, 멥, 셋, 벡터
(데이터를 담아두는 자료구조 클래스)
iterator****** 스펠링 주의
컨테이너에 대한 포인터
(컨테이너의 원소들을 순회하면서 접근하기 위해 만들어진 컨테이너 원소에 대한 포인터)
어떻게 쓰는지도 알아야 함...*********
algorithm - 템플릿 함수 ********** 스펠링 주의
(정렬, 탐색 같은 다양한 알고리즘 구현)
find, sort, reverse, remove, transform...
소문자로 써주세요..!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*******************

순차 컨테이너: vector, deque, list : 자료 순차처리
연관 컨테이너: set, map(key-value), multiset, multimap :정렬되서 들어감
***연관컨테이너의 종류 etc.. 
***연관 vs 순차 컨테이너
컨테이너 어댑터: 순차 컨테이너에 제약을 가해 데이터 정해진 방식으로만 입출력
stack, queue, priority deque

큐(FIFO: 피보나치 수열..***************!!!)
벡터, 데큐, 리스트
set은 안해봄..

벡터 사용하고 싶다?
#include <vector>
#include <queue>
#include <algorithm>
...

using namespace std;
int main()
{
 vector <int> v; <<< 벡터라서 꺾쇠 사용
 vector <int>:;iterator it; //반복자 사용방법
 vector <float> v2;
 v.push_back(45);
 v.push_back(23);
 v.push_back(89);
for(int i=0;i<v.size();i++){
 cout<<v[i]<<","<<v.at(i)<,endl;
}
for(it=v.begin(); it!=v.end();it++){
 cout<<*it<<endl;
}

벡터를 사용할 경우 쓰는 연산자 함수!!! 
begin() : 벡터의 처음 요소 리턴
etc..

요소를 하나하나 출력하기 위해서 iterator를 사용해주세요.
list든지 뭐든지.. 가능

set이라면..?

map**************
.size() ****************
iterator 시작 begin() / 마지막 end();*****************

순차 컽컨테이너, 연관 컨테이너


문제 주의깊게 볼 것..!

#include <set>
#include <map>

int main(){
 set <int> s;
 set <int> :: iterator st;
 s.insert(4);
 s.insert(2);
 s.insert(6);
for(st=s.begin();st!=s.end();st++){
 cout<<*st<<endl;
}

 map<int, string> m;
 m.insert(make_pair(1,"kim"));
}

sort를 하고 싶어도 algorithm 꼭 필요

C++ auto를 쓰면..
auto Pi = 3.14 ...
알아서 double 형태로 잡아줌.
C++ 11부터 지원.

람다 대수와 람다식
간단한 코드를 한 줄로 끝장보는 친구.
