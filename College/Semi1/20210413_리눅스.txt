**이건 시험범위가 아니다..!** 중간X
(1,2,3)
하드디스크 파티션 작업
파티션은 최대 4개까지

Linux > ext4, xfs
xfs = 최대 900TB까지 
포맷시에 ext4, xfs로 해볼 꺼임.

각각의 논리적인 분할 영역엔 
서로 다른 파일 시스템을 가질 수 있다.
(읽기, 쓰기도 가능)

파티션에 대한 이해
각각의 논리적인 분할 영역엔
서로 다른 파일 시스템을 가질 수 있음.

Native Partition
:리눅스가 설치 | 데이터 파일 저장

Swap Partition
:리눅스에서 가상 메모리 역할로 사용되는 파티션

가상 메모리
:주기억장치 용량에 한계로 인해..
하드디스크의 일부분을 빌려 주기억장치 처럼 사용.

CPU가 HDD에 접근하진 못함.
가상에 있는 걸 주기억장치(RAM)로 옮겨서 작업.
RAM에 2~3배 정도 크기로 설정.

in Native Partition
(4개도 부족하니.. 확장파티션을 늘리는 방향도 포함하여
최대 16개까지 생성 가능)
주 파티션:Primary Partition (<최대 4개)
>응용프로그램 위주

확장 파티션:Extended Partition
데이터, 사용자에게 제공되는 파티션 etc..

파일시스템이 설치되는 것이 아닌
논리파티션을(논리드라이브) 담는 역할
(like 달걀을 담는 그릇)

논리드라이브는 확장 파티션 내에 12개까지 생성

[주파[200], 주파[100], 확장[E:[30], F:[70]], 주파[...]
주: 포맷 0, OS설치, 부팅 파티션 사용 0
확: 포맷 + OS 설치 불가능
논리드라이브: 포맷가능

확장파티션 자체도 파티션으로 취급함.
주 파티션은 건드릴 수 없음. 
논리드라이브가 주 파티션의 번호를 가질 수 없음.
1, 2, [5, 6], 3

포맷 방법
Low level format
디스크에 물맂리적으로 트랙/ 섹터를 생성시키는 단계
'''
예전에 하드디스크 구입시 원반 형태에 금속 가운데에 구멍하나..
디스크를 살 때 format이란 작업을 함.
트랙, 섹터 부분을 함께 나눔.
'''
HIgh level "
파티션이 정해진 뒤 컴퓨터가 이해할 수 있도록 논리적인 순서를 주는 것.

클러스터 단위로 데이터가 저장.

하드디스크 장치명?
IDE, SATA(IDE타입보다 속도가 빠름.)
'''
IDE냐 SATA냐에 따라 이름이 달라진다고..

IDE>       hda / hdb...
SATA > /dev/sda
                /dev/sdb

brw-rw----. 1 root disk 8, 0  4월  6 05:03 /dev/sda
brw-rw----. 1 root disk 8, 1  4월  6 05:03 /dev/sda1(1디스크 - 1파티션)
brw-rw----. 1 root disk 8, 2  4월  6 05:03 /dev/sda2(2디스크 - 2파티션)
sda하나에 sda1, sda2 
파티션2개로 나눔.(논리적)

파티션 설정(손으로 직접해보는 것이 좋다고..)
'''
초창기엔 리눅스에 응용프로그램이 없기에
리눅스 종료 후 윈도우를 썼다고..
'''
확장파티션 안 스왑영역은 알아서 잡는다고 함..

*디스크 파티션 설정
-파티션 설정 이전에 계획설정
대상 디스크의 전반적인 용도를 결정
디스크의 전체 용량 확인
몇 개의 파티션으로 나눌지 결정
나뉘어지는 파티션의 용량 또한 결정
파티션별 레이블명 설정

파티션의 이름이 현존하는 디렉토리로 만들어준 뒤 마운트해주어야..

섹터번호를 확인하자.
sda1 start 2048 end 2099199
sda2 start 2099200 end 2097*** LVM(논리적 드라이브)

* < boot 디스크
파티션을 생성,수정,삭제 > fdisk
기존에 사용하고 있던 디스크 파티션을 재수정하여 저장하면
디스크에 존재하던 데이터가 모두 사라짐.
(리눅스는 그런거 안물어봄.)

fdisk 
-l / list
-p / print
-w / write
...

first sector 시작점.
last sector 끝점.
+250G

+350G

+400G(알아서 누르면 자동설정한다고 함.)

포맷하지도 않았고
현존하는 디렉토리와 마운트해야 쓸 수 있음..!

m은 메뉴.
마지막으로 지울 떄때에는 물어보지도 않고 지워버림.

1. 500
2. 200
3. 나머지

마지막 write까지 잊지말자.
container for logical partitions > e(extended)

500 > e
300, 200

n > e > enter > enter
n > (adding logical partition 5)

2,3,5,6만 사용가능
1 확장은 포맷 못함(그저 바구니)

200
200
300[300, 200,100]
(논리드라이브는 자동으로 남는 부분이 생성되는 시스템은 
아닌 것으로 보임.)

ls -l /dev/sdb*

디스크 포맷-mkfs/ mke2fs/ mks.ext4 ...
block size와 같은 정보들이 안나온다고..

200 200 300 200 100 [ext4로 포맷..]

(mkfs.(type) 파일시스템..]
[root@localhost miku]# mkfs -t ext4 /dev/sdb1
mkfs : make filesystem

[root@localhost miku]# mkfs.xfs /dev/sdb2

포맷은 했으나 마운트가 안되어 있기 때문에.

fsck: file system check
서버에서 돌렸다가 큰일나는 경우가 있음.
주로 복구하다가 터진다고(매번 하면 괜찮은데..)
Fixed...

1 루트파일
2 부팅 디스크 
언제나 점검해서 괜찮..

한동안 점검하지 않으면 fsck시 문제 발생..
재설치 해야할 수도 있음.

[root@localhost miku]# fsck /dev/sdb1
fsck from util-linux 2.32.1
e2fsck 1.45.6 (20-Mar-2020)
/dev/sdb1: clean, 11/12214272 files, 1044260/48828160 blocks

마운트
마운트 할 때 존재하는 디렉토리를 만들어야 함.

fstab***
절대경로를 알아내는 것..!
"부팅할 때마다 자동으로 부팅되어라.."

***************************
마운트를 하지 않은 상태에서
만든 디렉토리는 그저 디렉토리일 뿐
마운트를 하는 순간 
파티션..! 논.리.드.라.이.브.가 된다.

자동 마운트와 필요에 의한 마운트 사용과는 또 다르다고..

mount -t ext4 /dev/sdb1 /backup
[root@localhost miku]# ls /backup
lost+found
[root@localhost miku]# ls /cdrom
[root@localhost miku]# 

논리드라이브 vs 일반디렉토리
lost+found <<가 들어있다면 논리드라이브.

논리드라이브 안에 파일을 만든다음..
umount하게 되면 해당 파일에 것들이 사라진 것 같이 보임.
(그래서 비밀폴더와 같이 사용한다고 함.)

vi /etc/fstab << 리부팅 한 후에 적용된다.
마운트 포인트는 현존하는 디렉토리여야함.
(추가)/backup                 /backup                 ext4    defaults        0 0
(/dev/sdb1해도 됨.)

2번하고 5번 (수동으로 마운트 해준 친구.)
reboot

이러다 문제가 생기면 single mode에서 고쳐야..
mount > 다른 디스크들이 마운트가 되어있는지를 확인할 때 쓰임.

!!재부팅 후 이상없이 마운트 되었는지 확인!!
다음주엔 실습부분을 하는 걸로..

HDD bad block 점검
하드디스크를 3년마다 교체한다고..
(데이터가 손상되는 것 보다 낫다고..)
bad block이 나오기전에 미리 확인해두어야..
badblocks 명령어로 주기적인 디스크 점검.

자동차 유리꺶깨지듯이.. 배드블록 검사를 철저히..!

badblocks -v -o badblock1_sda1.txt /dev/sda1
>>배드블록에 대한 에러로그를 남김.

**수시
1강,2강,3강 중 나옴.

중간고사 전 주에 보는 것이기 때문에..
중요하게 확인 또 확인...!
