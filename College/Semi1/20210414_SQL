--(1번째)
/*시험관련*/
--객관식 18 : 1점
--주관식 단답형 문제 3 : 2점
--서술형 2: 3점

--Data Dictionary View
--Constraint을 찾아보세요~ 같은 것들..
--(1) self join
--1) select empno, enmae, mgr,
select empno, ename, mgr,
(select ename from emp where e.mgr = empno) as 직속상사명
from emp e;

--(2) inline view
--select e.empno, e.ename, e.mgr. i.ename
--from emp e left join (select empno,

select empno, ename, rownum
from emp;
 
select empno, ename, sal, rownum
from (select empno,ename,sal 
    from emp
    order by 3 desc)
where rownum <= 5;

--클러스터/rownum과 관계없이 돌아가는 order by
--where는 조건절이라 붙는다. 
--order by를 땡겨서 붙일 수도 있다.

--서브쿼리 이전에 배웠던 것에 큰 골격을 집어넣고
--그래도 해결이 안되는 경우에 서브쿼리를 넣거나..
--큰 골격이 되는 부분을 잡고
--부분적인 것은 서브쿼리로 마무리
--서브쿼리 안에 서브쿼리를 넣는 것은 비효율적..

--ex11)CTAS 기법으로 emp 테이블을 testemp로 복사하고 //Create Table As Select
--모든 사원의 월급을 자기 부서의 평균 월급으로 udpate 하라
select * from emp order by deptno;

drop table testemp;
create table testemp
as select * from emp;

update testemp t
set sal = (select trunc(avg(sal)) from testemp where t.deptno = deptno);
--밖에 있는 부서와 같은 부서만 들어가게 하는 방법..
--업데이트 시에 소수점 둘째자리에서 반올림한다고함..
select * from testemp
order by deptno;
select * from dept;
--힌트*
--select deptno, trunc(avg(sal))
--from testemp
--group by deptno;

--(1-> hr_user로 가시오.)


show user
desc user_tables

select table_name
from user_tables;

desc user_constraints
--제약조건 확인
--테이블 이름, 상대방이 참조한 테이블 이름 등을 확인할 수 있음.

desc user_cons_columns
--컬럼 이름 확인

select a.constraint_name, a.constraint_type
from user_constraints a join user_cons_columns b
on a.constraint_name = b.constraint_name
order by 2;

--C Not Null
--P Primary Key
--U unique
--F Foreign Key
--R
