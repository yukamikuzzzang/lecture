/*11강*/
객체 지향 프로그래밍?
Object-Oriented Programming

*객체란?
객체 이해에 어려운 이유는? 
책이나 가르치는 사람이 너무 어렵게 알려주는 것이 문제..

세상에 존재하는 모든 것. 프로그래밍에서 속성과 기능을 가지는 프로그램 단위.
객체(인간세계)

컴퓨터<객체>
------------------
CPU,<객체>
메모리,<객체>
HDD,<객체>
그래픽카드<객체>
(객체 안에 수많은 객체들)

사람
속성: 키, 몸무게
기능: 의사<사람을 치료하는 기능>
       군인<사격술을 겸비함>

체중계
속성: 바늘, 눈금
기능: 몸무게 측정

자전거
속성: 바퀴, 체인
기능: 이동수단

TV
속성: 채널, 사운드
기능: 미디어 방출

승용차
속성: 바퀴, 엔진
기능: 이동수단

자전거
속성: 바퀴, 체인
기능: 이동수단

객체(프로그램)
[눈에 보이지 않는 것들.]

날씨프로그램
속성: 온도, 미세먼지
기능: 날씨예보

사용자가 온도를 요구하면 언제든지 온도에 대한 데이터를 줄 수 있어야함.

사칙연산 프로그램
속성: +,-,*,/
기능: 연산기능

: 모든 객체들은 속성과 기능이 있을 수 있음
= 특정한 목적에 의해 만들어짐.
= 기능을 수행하기 위한 속성들이 있음.
= 하나의 기능, 기능들을 객체라 부를 수 있음.

*클래스란?
객체를 생성하기 위한 틀, 모든 객체는 클래스로부터 생성. 
(like 붕어빵 기계, 와플 기계)

자전거
... 레저용
... 일상용

승용차
... 소형차
... 대형차
... SUV

목적에 따라 객체가 달라짐.

붕어빵 기계
팥붕어빵 주세요! ... +팥 ... 팥 붕어빵
슈크림빵 주세요! ... +슈크림 ... 슈크림 붕어빵

붕어빵 기계는 변하지 않았지만 그 안에 들어간 것이 달라짐!

[		...복제...			]
그랜저<틀>	...	그랜저
속성: 색상, 바퀴		검정색, 일반 바퀴에
기능: 배기량		2000cc로 해주세요!
		...	그랜저
			흰색에 광폭 타이어에
			2500cc로 주세요!
		...	그랜저
			회색에 일반 바퀴에
			3000cc로 해주세요!
ex) 날씨프로그램
:요구사항
미세먼지만
초미세먼지만
섭씨만
화씨만
강수량만..

객체를 하나만 만든다 할지라도 반드시 틀이 필요하다.
객체의 부모라 할 수 있는 클래스!
개발자들이 할 일은 클래스를 만들어내는 것!
이걸 바탕으로 여러 객체를 만들어 메모리에 탑재하는 것..!

가비지컬렉터,GC
여러개의 객체를 만들어 사용하다
레퍼런스를 푼 상태로 사용하지 않는 객체를 알아서 회수함.
현재 객체에서 쓰고 있는 프로그램은 건드리지 않음.
<누구도 참조하지 않고 사용하지 않는 객체는 알아서 회수해감.>

클래스: 틀(객체를 뽑아내기 위한)
개발자는 클래스를 만들고 이를 바탕으로 객체를 생산해낼 수 있다.

*클래스의 구성요소
클래스는 속성(멤버 변수)와 기능(메서드)로 구성된다.

속성(멤버 변수)
안장, 핸들, 바구니, 기어, 페달, 바퀴

재질, 가격, 크기 등등에 따라 달라짐.

기능(메서드)
기어 변속, 가속, 브레이크


객체지향프로그래밍의 기법..!
이걸 자바에서 채택한 이유..?

객체를 만들어놓으면 부품하나하나를 모듈화할 수 있음..!

"안장을 아주 좋은 걸로 바꿔주세요..!"
남이 만들어놓은 안장을 달기만 하면 요구사항을 충족시킬 수 있음.

만들어져 있는 좋은 기능들을 가져와서 나만의 프로그램을 만들 수 있음.

금융. 정확한 연산이 필수적인 부분.
지금까지 해왔던 기능들을 보며 좋은 기능이라면 내가 그걸 가져와서 내가 만들어놓은 기능들과 같이 씀.
안장도 하나의 객체가 될 수 있음.

/*12강*/
객체: 세상에 존재하는 모든 것
클래스: 이를 뽑아내기 위한 틀

클래스를 만들고, 클래스로부터 객체를 생성하는 방법을 학습

*클래스 제작
클래스는 멤버 변수(속성), 메서드(기능) + 생성자 등으로 구성
(접근제한자 public*)

public class Grandeur { 	//일반적으로 클래스이름의 첫문자는 대문자
	//멤버 변수(속성), 변수 선언과 동일.
	public String color;
	public String gear;
	public int price;
	
	//생성자: 클래스 이름과 동일. (대문자) 
	//생성할 때 필요한 기능을 기술 없다면 비워두어도 무관.
	//외부에서 클래스를 이용해 객체를 만들 때에 가장 먼저 호출되는 것.
	public Grandeur () {

	}
	
	//메서드: 접근제한자, 반환값의 자료형, 이름(){...}
	//일반적으로 소문자로 씀.
	//나중에 ( )안에 파라미터를 넣을 수도 있음. 
	//void = 반환값이 없음.
	//반환 값이 있다면 안에 return을 써주면 됨.
	public void run() {
		//메서드 = 함수	
		//run()이 실행할 기능이 들어가야함.
		//return "!";
	}
	//메서드
	public void stop() {
	
	}

}
클래스에서 중괄호가 시작하고 끝나는 부분 사이에
멤버 변수, 메서드, 생성자를 구성..!

코딩을 하다보면 자연스럽게 익힐 것들.
이클립스를 이용해 제작해보자.

패키지란? like 폴더
성질이 같은 클래스들을 모아서 관리할 수 있음.

*객체 생성
클래스로부터 'new'를 이용해 객체 생성
객체 마다 닉네임을 정할 수 있음.

Grandeur myCar1 = new Grandeur( ); // 생성자가 호출, 메모리에 올라감
닉네임을 바탕으로 멤버변수에 접 '.'라는 접근 지정자로 접근( . )

myCar1[주소] ....> Grandeur 객체
레퍼런스(참조)

myCar2[주소] ...> Grandeur 객체
레퍼런스

(레퍼런스가 끊어지게 되면 GC가 알아서 메모리에 할당된 부분을 회수해감.)
Bicycle, Grandeur...

생성자에 값을 아무것도 넣지 않고 호출할 수 있음.
생성자 안에 있는 부분이 호출.
아무 인자도 없는 생성자는 기본 생성자로 불림.

객체 생성시 객체가 생성되는 곳에 값을 받음.

public Bicycle(String c, int p){

}
(생성자인데 string하나 int 값하나 가져감.)

객체안에 객체는 또 어떻게 들어가는지...
자바의 꽃이라 불리는 부분.

클래스 만드는 법. 클래스(생성자를 호출해)를 통해 객체를 만드는 방법.

+클래스 생성 시 생성자에 쓸게 없어도 반드시 만들어야하나요?
클래스를 만드는 이유는 그 클래스를 다른 곳에 쓰기 위함임.
생성자를 생성하지 않는다면 그러한 이유가 없음. 생성자를 만드는 게 좋다.

그래서 보통은 생성자를 초기화한 상태로 만듬
public class NAME(){ }

이걸 변형하면 사용자들의 요구대로 커스텀 주문 가능..!
(생성자를 만들지 않아도 기본생성자를 만들기는 함. 하지만
객체가 존재하려면 생성자가 필수라는 점..!)

객체 = 인스턴스

/*13강*/ 
메서드: 메서드 선언 및 사용법에 대해 학습!

객체를 통해 프로그램을 짜는 것 ...> 객체지향 프로그래밍.

*메서드 선언과 호출
메서드도 변수와 같이 선언 및 정의 후 필요시 호출해서 사용합니다.

[메서드 선언 및 정의]
//메서드 정의 부분
public void getInfo() { /* <선언부>
      메서드 정의 부분<정의부>
} */

접근자 public : 메서드의 접근을 허용하는지 여부를 알려주는 것.
반환형 void   : 메서드를 호출 후 실행 이후 데이터를 반환할 때의 자료형
(String으로 반환 시 String, 배열로 반환시 Array, 없다면 void)
메서드 이름   : 소문자로 시작(하기로 약속) + 낙타 표기법 사용 [getInfo](동사 + 목적어 : 역할에 초점)

[메서드 호출]
ChildeClass childClass = new ChildClass( );
childClass.getInfo( ); //도트 연산자로 호출. <호출부>

파라미터 부분은 필요에 따라 0~그 이상 다양하게 쓸 수 있다.
그러나 개수보다는 자료형이 무엇보다 중요하다!

*중복 메서드(overloading)
똑같은 것으로 여러개 만들 수 있으나 조건이 있음.
메서드 이름은 중복되나 매개변수의 개수/ 타입이 다른 메서드를 만들 수 있음.

public void getInfo( ){ }
public void getInfo(int x, int y){ }
public void getInfo(String s1, String s2){ }

동일한 메서드이지만 파라미터의 차이를 두고 여러개를 만들 수 있다!

*접근자
private : 외부에서 호출 불가. 내부에서만 호출(사용) 가능.
public  : (오직 public만) 외부에서도 호출 가능.

protected 등은 다음에 알아보자.

메서드 선언,정의,호출 하기
매개변수로 메서드 호출하기
중복 메서드: 메서드 이름이 같아도 매개변수가 다르다면 여러개의 같은 이름을 가진 메서드를 만들 수 있음(메서드 오버로딩: overloading) 
모든 메서드를 다 호출하는 것은 안된다. : 접근(지정)자

/*14강*/
객체와 메모리
메서드 선언, 정의하고 호출부에서 호출!

객체가 생성될 때 메모리에서 어떻게 생성되는지, 레퍼런스가 끊긴객체는 메모리에서 어떻게 이용이 되는지? (****)

*메모리에서 객체 생성(동적 생성)
객체는메모리에서 동적으로 생성. 객체가 필요없어지면 GC(Garbage Collector)에 의해 제거됨.

class ....(new)...생성...> 객체생성 주소 .....> obj.         
			    obj.<임자없는 객체> ...GC...> 제거
 			<메모리>

ex)
ChildClass child = new ChildClass();

child == '레퍼런스'
레퍼런스 == 메모리에 생성된 객체에 메모리 주소를 담고 있는 친구
객체는 메모리 공간의 별도로 생성되어 있음.
메모리의 주소값만 child에 들어있음. (이를 레퍼런스라 부름...가리킨다)

어떠한 레퍼런스와도 관계가 없다고 GC가 판단하면 메모리를 순회하다 해당객체를 지워버림.

개발자는 객체를 쓰다가 해당 객체가 필요없다 느낄 때 개발자는 이에 신경쓸 필요없이 GC가 알아서 해당 객체를 없애줌.

*레퍼런스(가리킨다)
생성한 주소를 변수에 저장하는 것 == 레퍼런스
System.out.println( ); 으로 child를 출력하면 객체의 시작주소를 출력.

*자료형이 같아도 다른 객체(!!!!)
클래스가 같으면 같은 객체? X! 다른객체다..!

*null과 NullPointException
레퍼런스에 null 저장되면 객체와의 연결이 끊기며 더 이상 객체를 이용할 수 없음. null로 관계를 끊겼는데도 불구하고 다시 메서드를 호출하려 하거나 속성을 접근하려 한다면 NullPointerException


클래스로부터 생성되는 객체들은 모두 다른 공간에 있음.
그 객체를 가리키는 것을 레퍼런스라 부름
레퍼런스는 new로 연결되어있으나 null로 그 관계가 끊기면 더 이상 레퍼런스는 객체를 가리키지 못함. 가리키지 못하는 객체는 GC에 의해 회수되고 레퍼런스에 더 이상 접근하지 못한다.

new를 통해서 동적으로 객체를 생성 후 다시 연결할 수 있음.

/*15강*/
생성자와 소멸자 그리고 this 키워드

생성자: 사용자 정의 생성자 + 기본 생성자
소멸자: (레퍼런스와 관계가 끊겨 GC가 회수할 때 나오는 친구)

*디폴트 생성자
객체가 생성될 때 가장 먼저 호출되는 생성자, 만약 개발자가 명시하지 않아도 컴파일 시점에 자동 생성된다.

ObjectEx obj1 = new ObjectEx( );

new 키워드로 객체가 생성되는 시점에 디폴트 생성자가 실행된다..!
(생성자를 명시하지 않았다 하더라도..!)

*사용자 정의 생성자
디폴트 생성자 외에 특정 목적에 의해 개발자가 만든 생성자로, 매개변수에 차이가 있음.

ObjectEx obj2 = new ObjectEx(10);

---

public ObjectEx(int i){
	System.out.println("UserDefined Constructor");
	num = i;
}

=====
int arr[] = {10, 20, 30};
ObjectEx obj3 = new ObjectEx("Java", arr);

---
public ObjectEx(String s, int i[]){
	System.out.println("UserDefind constructor");
	str = s;
	nums = i;
}

매개변수는 내가 필요한 만큼 필요한 자료형을 얼마든지 만들어서 사용할 수 있음.

*소멸자
객체가 GC에 의해 메모리에서 제거 될 때 finalize() 메서드가 호출됨.

ObjectEx Obj4;

obj4 = new ObjectEx();
obj4 = new ObjectEx();

/*
	기존에 있던 것이 아닌 새로운 객체와의 관계를 가짐.
*/


System.gc();
/*
	finalize()라는 메소드를 호출. GC를 빠르게 부르도록 함.
*/

//finalize()는 우리가 꼭 모든 클래스에 명시를 하지 않아도 됨.
(명시하는 경우가 거의 없음)
system.gc( )도 거의 쓰지 않음. 가급적 GC가 바로 작동하도록 요청하는 것.

java는 기본적으로 개발자가 메모리를 직접 관리하지 않기에 일반적으로 System.gc()를 사용하는 경우는 드물다.
언제 GC가 돌지는 아무도 알 수 없음.

*this 키워드
지역변수로 호출받은 값을 전역변수에 담고 싶을 때 쓴다!

생성자! 사용자 정의 생성자!
소멸자(참고)(거의 사용할 일은 없음)
this. (****)
[객체를 여러 개를 사용하다보면 내가 쓰고 있는 것이 어떤 객체인지 알 필요가 있음.]

https://xxxelppa.tistory.com/75
배열이 객체인 이유.

int[] a; 자료형 == 클래스
int[] a = new int[5]; ..> 객체 생성